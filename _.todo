REVIEW Features
2_ use dependency injection to resolve mongoose models
32_ Mongoose Query Helpers
33_ use mongoose plugin to retrive name attribute depend on user language

SECTION ALERTS
1_ if a certin environment not available such as a "NODE_ENV" ..etc, and throw an error before building
2_ eleminate register mutiple router to the same app or router instance by checking if the id of the router is registred before
3_ make sure that two router doesn't have the same path, check it in the router decorator
4_ attached router method (http method) shouldn't have the same paths, consider make a checker function

TODO
1_ implement deferent auth strategies
7_ read all files to get the string in `translate` function and auto export it to json file
8_ refresh token
9_ important (curd generator)

SECTION IMPORTANT
1_ an application instance not allowed to be accesses, just in server class
2_ upon the validation layer hierarchy the nested object request not allowed
3_ user model should not be used explicty
4_ model, repo and routes used as component 

SECTION mongoose model
1_ add hook decorator
2_ virtuals
3_ query helper
4_ find way to seperate properties from methods in EntitySchema

https://www.npmjs.com/package/injection-js
web socket class

use http://www.hygen.io/create style for documention section


Refactor the "Reactor" class to work with event
Modify the request interface to be generic in order to give the body type
Get the type of the decorated attr only



// import { Schema, model } from "mongoose";
// import { CustomersRouter, SubCustomersRouter } from "./customers.routes";

// function Wrapper(configuration) {
//     return function (target) { }
// }

// @Wrapper({
//     models: [],
//     routes: [
//         {
//             path: 'customers', guard: ['or middleware'], router: CustomersRouter, children: [
//                 { path: 'sub', router: SubCustomersRouter }
//             ]
//         }
//     ]
// })
// export class CustomersModule { }

// // Why i need to create a new mongoose model instance ?????
// // inject the wrapper class into sub router and assign it
// // inject the wrapper class mean retrive the injector that hold the class instance

// // ask about this type of defining routes path and it's children or by injection style or by calling it
// // explicity Wrapper.assginTo(superRouter, router) | Wrapper.assginTo(superRouter, subSuperRouter, router)

// // # resolve all route like urlSegment angular

// // Both style must be implemented the angular style, and Wrapper style

// // does he really need this style ?
// // what about he just wanna to use one RouterClass
// // should just user @Router and define path there
// // and about the guard(middleware) just add them when you define router to easy setup
// // i think that this should be used when you add more than just path and router

// // when you wanna to set a list of dependencies because he inject them in router classs
// // constructor(private one: One){}
// // { path: 'customers', deps: [One] }
// // try to make use of angular way by injecting it directly

// // Take care of error handling


// REVIEW  controller => handler(service => unitofwork(repo, model))
/**
 * unitofwork(repo, model) => first prepare your model then expose it using the repo class and facilitate the methods
 * service => unitofwork(repo, model) => after composing the repo and model you need to leverage them
 * controller => handler(service => unitofwork(repo, model)) the controller like a king will ask the service
 * to do something, the service will be prepared to (validate | ask hassan) and check that everything is okay,
 * to procced the operation then
 * it asks the repo to hold the data in the model(database)
 */




// const createDatabaseStatement = 'CREATE DATABASE testDB';
// const createTableStatement = `
// CREATE TABLE testTable (
//         id int UNSIGNED AUTO_INCREMENT PRIMARY KEY,
//         title VARCHAR(255) NOT NULL,
//         body VARCHAR(255) NOT NULL
// )`;

// router.use('/user', function (req, res, next) {
//     console.log('Request URL:', req.originalUrl)
//     next()
//   }, function (req, res, next) {
//     console.log('Request Type:', req.method)
//     next()
//   })
// Show the request info for any type of http method that call user
// ex:: cound how many user middleware called

// app.use(function (req, res, next) {
//     console.log('Time:', Date.now())
//     next()
// })
// Called every time (app here is application instance)

// app.use('/user/:id', function (req, res, next) {
//     console.log('Request Type:', req.method)
//     next()
// })
// Show the request info for any type of http method that call user
// (app here is application instance)

// to escape the next middleware call next('route')
// will escape the all middleware but next() will continue to next middleware at specific point

// This matching all route middleware under route instance and prefixed with api
// router.all('/api/*', requireAuthentication);

// this will only be invoked if the path starts with /bar from the mount point
// router.use('/bar', function (req, res, next) {
// ... maybe some additional /bar logging ...
//     next();
// });

// Intercept id param under route instance and called once at a time (intercept id param)

// router.param('id', function (req, res, next, id) {
//     console.log('CALLED ONLY ONCE');
//     next();
// });

// router.get('/user/:id', function (req, res, next) {
//     console.log('although this matches');
//     next();
// });

// router.get('/user/:id', function (req, res) {
//     console.log('and this matches too');
//     res.end();
// });
